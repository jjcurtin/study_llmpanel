---
title: "Qualtrics LLM Panel Preregistration"
author: "Colin Maggard and Claire Punturieri"
date: "`r lubridate::today()`"
output: 
  html_document:
    toc: true 
    toc_depth: 4
format:
  html:
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

# To do

Claire
 - update message_id tag

Colin:
 - Add in context and survey_id tags

```{r}
library(stats)
library(lme4)
library(tidyverse) 
library(psych) 
library(car)
library(broom)
```

# Study Overview

## Specific Aims

This project aims to measure and compare individuals' stated tone preferences, stated style preferences, and actual message preferences for messages generated by GPT-4o designed for a continuing care monitoring and support system for patients in early recovery from alcohol use disorder (AUD).

Specifically, this project pursues the following aims:

**AIM 1:** Generate messages tailored to simulated participants with varying AUD lapse contexts.

**AIM 2:** Collect data on stated preferences for message tone and style, as well as actual message ratings.

**AIM 3:** Analyze the data to compare tone and style preferences and to assess the relationship between stated preferences and actual message ratings. 

## Data

 - Future tense
 
Five hundred individuals (50 pilot subjects) who score above XX on the Alcohol Use Disorder Identification Test (AUDIT) Self-Report (suggestive of possible alcohol use disorder) will be provided with a set of linguistic styles (6) and tones (2) designed to be applied to messages generated with the use of large language models (LLMs). They will be asked to rate each of these tones and styles on a 1 to 7 likert scale on how much they like each category. Then, participants will be prompted with a series of LLM-generated messages across a set of 4 simulated user contexts in which a lapse risk (high, low) and lapse risk change (increasing, decreasing) will be reported. They will be asked to rate each of these messages on a similar 1 to 7 likert scale on how much they find each of these messages to be helpful.

We evaluated stated and actual preferences for each tone and style category, determined if there was an interaction between stated and actual preferences, and assessed the impact that demographic characteristics have on stated and actual preferences.

# Purpose of Preregistration

## Outcomes

## Focal and Secondary Effects

# Data Generation

```{r}
set.seed(1)
n_participants <- 500
standard_deviation <- 0.3

tones <- c("legitimizing", "caring_supportive", "self_efficacy",
           "acknowledging", "value_affirmation", "norms")
styles <- c("formal", "informal")
contexts <- c(
  "high_increasing", "high_decreasing",
  "low_increasing", "low_decreasing"
)
```

Preferences set-up.
```{r}
tone_means <- c(
  legitimizing      = 1,
  caring_supportive = 2,
  self_efficacy     = 3,
  acknowledging     = 4,
  value_affirmation = 5,
  norms             = 6
)
tone_sex_adj <- list(
  male = c(
    legitimizing = -0.3,
    norms        =  0.8
  ),
  female = c(
    legitimizing =  0.8,
    norms        = -0.3
  )
)
get_adjusted_tone_mean <- function(tone, sex) {
  base_mean <- tone_means[tone]
  adj <- 0
  if (!is.null(tone_sex_adj[[sex]])) {
    adj <- tone_sex_adj[[sex]][tone]
    if (is.na(adj)) adj <- 0
  }
  return(base_mean + adj)
}

style_means <- c(
  formal            = 3,
  informal          = 5
)
style_sex_adj <- list(
  male = c(
    formal       = -0.3,
    informal     =  0.8
  ),
  female = c(
    formal       = 0.8,
    informal     =  -0.3
  )
)
get_adjusted_style_mean <- function(style, sex) {
  base_mean <- style_means[style]
  adj <- 0
  if (!is.null(style_sex_adj[[sex]])) {
    adj <- style_sex_adj[[sex]][style]
    if (is.na(adj)) adj <- 0
  }
  return(base_mean + adj)
}
```

Participant generation.
```{r}
n <- n_participants
repeat_even <- function(x, total) {
    rep(x, length.out = total)
}
participant_id <- 1:n
age               <- sample(repeat_even(18:65, n))
sex               <- sample(repeat_even(c("male", "female"), n))
gender_id         <- sample(repeat_even(c("man", "woman", "nonbinary"), n))
sexual_orientation<- sample(repeat_even(c("heterosexual", "gay/lesbian", "bisexual", "other"), n))
race_ethn         <- sample(repeat_even(c("white", "black", "asian", "hispanic", "other"), n))
education         <- sample(repeat_even(c("high_school", "bachelor", "master", "phd"), n))
income            <- sample(repeat_even(seq(20000, 100000, by = 20000), n))
marital_status    <- sample(repeat_even(c("single", "married", "divorced", "widowed"), n))
no_in_household   <- sample(repeat_even(1:6, n))
minoritized       <- sample(repeat_even(c("yes", "no"), n))
income_adj <- as.integer(income / no_in_household)
participants <- data.frame(
    participant_id,
    age,
    sex,
    gender_id,
    sexual_orientation,
    race_ethn,
    education,
    income,
    marital_status,
    no_in_household,
    minoritized,
    income_adj
)
```

Tone preference generation
```{r}
participant_id <- rep(participants$participant_id, each = length(tones))
participant_sex <- rep(participants$sex, each = length(tones))
tone <- rep(tones, times = nrow(participants))

adjusted_means <- mapply(get_adjusted_tone_mean, tone, participant_sex)

tone_rating <- rnorm(length(tone), mean = adjusted_means, sd = standard_deviation)
tone_rating <- pmin(pmax(tone_rating, 1), 7)
tone_rating <- round(tone_rating)
tone_preferences <- data.frame(
  participant_id = participant_id,
  tone = tone,
  tone_rating = tone_rating
)
#tone_preferences <- merge(tone_preferences, participants, by = "participant_id", all.x = TRUE)
```


Style preference generation
```{r}
participant_id <- rep(participants$participant_id, each = length(styles))
participant_sex <- rep(participants$sex, each = length(styles))
style <- rep(styles, times = nrow(participants))

adjusted_means <- mapply(get_adjusted_style_mean, style, participant_sex)

style_rating <- rnorm(length(style), mean = adjusted_means, sd = standard_deviation)
style_rating <- pmin(pmax(style_rating, 1), 7)
style_rating <- round(style_rating)
style_preferences <- data.frame(
  participant_id = participant_id,
  style = style,
  style_rating = style_rating
)
#style_preferences <- merge(style_preferences, participants, by = "participant_id", all.x = TRUE)
```


Message preference generation for tone x style (x context eventually).
```{r}
participant_id <- rep(participants$participant_id, each = length(styles) * length(contexts) * length(tones))
participant_sex <- rep(participants$sex, each = length(styles) * length(contexts) * length(tones))
tone <- rep(rep(tones, each = length(styles) * length(contexts)), times = nrow(participants))
style <- rep(rep(styles, each = length(contexts)), times = length(tones) * nrow(participants))
# not using context currently but adding in here
context <- rep(contexts, times = length(tones) * length(styles) * nrow(participants))

adjusted_tone_means <- mapply(get_adjusted_tone_mean, tone, participant_sex)
adjusted_style_means <- mapply(get_adjusted_style_mean, style, participant_sex)

message_rating_tone <- rnorm(length(tone), mean = adjusted_tone_means, sd = standard_deviation)
message_rating_style <- rnorm(length(style), mean = adjusted_style_means, sd = standard_deviation)
message_rating <- (message_rating_tone + message_rating_style) / 2

message_rating <- pmin(pmax(message_rating, 1), 7)
message_rating <- round(message_rating)
message_preferences <- data.frame(
  participant_id = participant_id,
  tone = tone,
  style = style,
  message_rating = message_rating
)

# add in ids for messages
# eventually want to add in a cross for context
message_lookup <- message_preferences |> 
  distinct(tone, style) |> 
  arrange(tone, style) |> 
  mutate(message_id = row_number())

message_preferences <- message_preferences |> 
  left_join(message_lookup, by = c("tone", "style")) |> 
  select(participant_id, tone, style, message_id, message_rating)

```

Combine message, style, and tone preferences into one dataset:
```{r}
d <- participants |>
  left_join(message_preferences, by = "participant_id") |> 
  left_join(style_preferences, by = c("participant_id", "style")) |> 
  left_join(tone_preferences, by = c("participant_id", "tone"))


d |> glimpse()
```

```{r}
d |> pull(age) |> hist()
d |> pull(tone_rating) |> hist()
d |> pull(style_rating) |> hist()
d |> ggplot(aes(x = tone,
                y = tone_rating)) +
  geom_col()
d |> ggplot(aes(x = style,
                y = style_rating)) +
  geom_col()
```

Simulated data should have:

 1. We should see clear differences in actual ratings of messages. Within each tone/style, people's ratings should be pretty similar to one another (low variance) but between tone/style ratings should be noticeably different (high variance).
 
 Example: people might rate the norms tone at around a 6/7 but the self-efficacy tone at around a 3/7.

 2. Stated preferences should match actual ratings.
 
 Example: if someone says they like "informal" messages, then their ratings of actual "informal" messages should be high, too.

 3. We want to observe a demographic difference. Create a sex variable (male/female) where there is a clear difference in tone/style preferences.
 
 Example: prefer "norms" messages and women prefer "legitimizing" messages.

 4. We want tone and style to interact.
 
 Example: all tones that are crossed with the "informal" style to have higher actual ratings than all tones crossed with the "formal" style.

Some other notes for making it realistic!

 - Make sure there's a little bit of randomness (we don't want two given person's ratings to be identical, but we still want the patterns above to be obvious)
 - Make sure that not every person's stated preference perfectly matches their actual message ratings
 - Keep ratings in the real range of values we'll be collecting (e.g., 1-7 Likert scale)

# Preregistered Analyses

Variables:
 - participant_id
 - style_rating (how much would you like to receive a message in this style)
 - tone_rating (how much would you like to receive a message in this tone)
 - message_rating (how helpful do you find this message)
 - style (informal, formal)
 - tone (value affirmation, norms, acknowledging, self-efficacy, caring/supportive, legitimizing)
 - context (high/increasing, low/increasing, high/decreasing, low/decreasing)
 - age
 - sex
 - gender_id
 - sexual_orientation
 - race_ethn
 - education
 - income
 - marital_status
 - no_in_household
 - minoritized
 - income_adj (will be calculated as: income / no_in_household)
 
## Models 1 & 2 - Style and tone stated preferences

Answers:

 - Do people have message tone and/or style preferences? (stated preferences from categories)
 - Are there demographic differences in these preferences? (demonstrated here using sex variable)
 
By testing:

 - The main effects of style and tone separately
 - The main effect of sex
 - The interaction between sex and style/tone (and any other demographic variables we wish to include)

For style:
```{r}
m1 <- lm(style_rating ~ style*sex, d)
broom::tidy(m1)
```

For tone:
```{r}
m2 <- lm(tone_rating ~ tone*sex, d)
broom::tidy(m2)
```

## Model 3 - Style and tone actual ratings

Answers:

 - Do people have actual message tone and/or style differences?
 - Is there an interaction between tone and style?
 - Are there demographic differences in actual message ratings?
 
By testing:

 - The main effects of style and tone condition on actual ratings
 - The interactive effect of style and tone
 - The main effect of sex on actual ratings
 - While accounting for individual differences by including random intercepts for participants and messages
 - While modeling individual variability in effects of style and tone with random slopes by participant
 - While accounting for variation on sex (or any other demographic characteristics we choose to measure) within the message_id grouping variable
 
> This would be the model where we could incorporate context if we are able to do the necessary randomization for that. Then I think we'd need random slope for context within participant

> For both of our LMEMs we need to decide how we are going to handle non-convergence and also put it in the preregistration. We should talk about what are the most important variables to retain at our next meeting.

```{r}
m3 <- lmer(message_rating ~ style*tone + sex +
             (1 + style*tone | participant_id) + (1 + sex | message_id),
           d)

summary(m3)
```

## Model 4 - Concordance between preferences and actual ratings

Answers:

 - Do message tone and style preferences correspond to actual ratings?
 
By testing:

 - Main effects of style and tone preferences on actual ratings
 - While accounting for individual differences by including random intercepts for participants and messages
 - While modeling individual variability in effects of style and tone with random slopes by participant
  - While accounting for variation on sex (or any other demographic characteristics we choose to measure) within the message_id grouping variable

> Unsure if it conceptually makes sense to have an interaction here between tone_rating and style_rating.

```{r}
m4 <- lmer(message_rating ~ tone_rating + style_rating + sex
             (1 + tone_rating + style_rating | participant_id) +
             (1 + sex | message_id),
           d)
```

## Models 5, 6, & 7- Within and between comparisons (ICC)

Answers:

 - Are participant ratings of messages more different across tone categories than within tone categories?
  - Are participant ratings of messages more different across style categories than within style categories?
  - Are participant ratings of messages more different across tone/style combinations than within tone/style combinations?
  
> I believe it would be appropriate for us to look at ICC2 or ICC3 here, but they would answer slightly different questions. ICC2 assumes a random sample of raters and ICC3 assumes a fixed sample. ICC2 is more appropriate if we want to generalize. ICC3 is more appropriate if we are interested in characterizing these particular participants. I'm leaning towards 2.

```{r}
## this will look at tone and style separately
d |> 
  group_by(participant_id, tone) |>
  # here I am summarizing across four contexts
  summarise(mean_rating = mean(message_rating, na.rm = TRUE),
            .groups = "drop") |> 
  pivot_wider(names_from = participant_id, values_from = mean_rating) |>
  select(-tone) |> 
  ICC()

d |> 
  group_by(participant_id, style) |> 
  summarise(mean_rating = mean(message_rating, na.rm = TRUE),
            .groups = "drop") |> 
  pivot_wider(names_from = participant_id, values_from = mean_rating) |>
  select(-style) |> 
  ICC()

## this will look at the within and between effect across tone/style combinations
d |>
  group_by(participant_id, message_id) |>
  summarise(mean_rating = mean(message_rating, na.rm = TRUE),
            .groups = "drop") |>
  pivot_wider(names_from = participant_id, values_from = mean_rating) |>
  select(-message_id) |>
  ICC()
```

> ICC does not work with ranked ordered categories, but there is a rank ICC package we could consider using: https://pmc.ncbi.nlm.nih.gov/articles/PMC10592008/ https://github.com/shengxintu/rankICC This paper has only been cited 10 times so might not be the best option.

 
# Notes

 - Are tone/style_rating and message_rating comparable? Should preferences also be "helpful" instead of like?
 - Should gender_id include specific categories?
 - Treat race/ethnicity as separate variables?
 - We need to add in a variable accounting for context and study iteration
 - "I/we" category???

 